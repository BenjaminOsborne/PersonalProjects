@using System.IO
@using System.Collections.Immutable;
@using AccountProcessor.Components.Services;
@page "/"
@rendermode InteractiveServer
@inject Services.IExcelFileHandler ExcelFileHandler;
@inject Services.ITransactionCategoriser Categoriser;
@inject IJSRuntime JS

<!-- Add icon library: https://fontawesome.com/v4/icons/ -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- Button Style -->
<style>
    .btn {
        background-color: DodgerBlue;
        border: none;
        color: white;
        padding: 2px 2x;
        font-size: 14px;
        cursor: pointer;
    }

    /* Darker background on mouse-over */
    .btn:hover {
        background-color: RoyalBlue;
    }
</style>

<PageTitle>Home</PageTitle>

<h1>Account Processor</h1>

<p />
<hr />

<p role="status"><strong>Last Action Result</strong>: @LastActionResult</p>

<hr />

<p style="border:thin">
    <table style="width:auto" cellpadding="5">
        <tbody>
            <!-- Coop Bank extract -->
            <tr>
                <td><label><strong>Coop Bank: Reverse File</strong></label></td>
                <td>
                    <button class="btn btn-primary">
                        <InputFile OnChange="@CoopBankReverseFile" accept=".csv" />
                    </button>
                </td>
                <td><label>Takes a raw CSV from Co-op Bank, reverses the transactions and downloads in standard format</label></td>
            </tr>

            <!-- Santander Bank extract -->
            <tr>
                <td><label><strong>Santander: Extract</strong></label></td>
                <td>
                    <button class="btn btn-primary">
                        <InputFile OnChange="@SantanderProcessFile" accept=".xlsx" />
                    </button>
                </td>
                <td><label>Takes a converted xlsx from Santander and downloads in standard format. (Must be saved to xlsx manually)</label></td>
            </tr>

            <!-- Categorise transaction files -->
            <tr class="border-top">
                <td><label><strong>Categorise: </strong></label></td>
                <td>
                    <button class="btn btn-primary">
                        <InputFile OnChange="@Categorise" accept=".xlsx" />
                    </button>
                </td>
                <td><label>Loads an xlsx with Date, Description & Amount columns and runs categorisation. </label></td>
            </tr>

            @if (TransactionsFullyLoaded())
            {
                <!-- Export categorised -->
                <tr class="border-top">
                    <td><label><strong>Export Categorised</strong></label></td>
                    <td>
                        <button class="btn btn-primary" @onclick="() => ExportCategorisedTransactions()">Export</button>
                    </td>
                    <td><label>Finally, exports the categorised transactions by category, for storage in LifeOrganisation file. </label></td>
                </tr>
            }
        </tbody>
    </table>
</p>

<hr />

<label>Month:</label>
<input type="month" value="@Month?.ToString("yyyy-MM")" @onchange="e => OnSetMonth((string?)e.Value)">
<button @onclick="() => SkipMonth(-1)"><i class="fa fa-arrow-left" aria-hidden="true"></i></button>
<button @onclick="() => SkipMonth(+1)"><i class="fa fa-arrow-right" aria-hidden="true"></i></button>
<p/>

@if (TransactionsFullyLoaded())
{
    <hr />

    <label ><strong>Add New Section:</strong></label>
    <select style="margin-right: 5px" value="@NewSectionName" @onchange="e => NewSectionCategoryName = (string?)e.Value">
        <option value="0" selected>Choose Category</option>
        @foreach (var cat in Categories!.Value)
        {
            <option value="@cat.Name">@cat.Name</option>
        }
    </select>

    <input style="margin-right: 5px" placeholder="Section Name..." value="@NewSectionName" @onchange="e => NewSectionName = (string?)e.Value" />

    <button class="btn" @onclick="() => CreateNewSection()"><i class="fa fa-plus"></i></button>

    /* UnMatched Rows */
    @if (TransactionResultViewModel.UnMatchedRows.Any())
    {
        <hr />
        <label style="color:red; font-size:large"><strong>UnMatched</strong></label>

        <table style="width:auto" cellpadding="5">
            <thead>
                <tr class="border-bottom-thick">
                    <th>Date</th>
                    <th>Transaction</th>
                    <th class="border-right">Amount (£)</th>
                    <th>Category</th>
                    <th>Match On</th>
                    <th>Description</th>
                    <th>Once</th>
                    <th>Match</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var row in TransactionResultViewModel.UnMatchedRows)
                {
                    <tr class="border-bottom">
                        <td class="fitwidth">@row.Transaction.Date.ToString("dd/MM")</td>
                        <td class="fitwidth">@row.Transaction.Description</td>
                        <td class="border-right" style=@row.StyleColor>@row.DisplayAmount</td>
                        
                        <td>
                            <select value="@row.SelectionId" @onchange="e => row.SelectionId = (string?)e.Value">
                                <option value="0" selected>Choose Section</option>
                                @foreach (var cat in AllSections.Value)
                                {
                                    <option value="@cat.Id">@cat.Display</option>
                                }
                            </select>
                        </td>

                        <td>
                            <input placeholder="Match on" value="@row.MatchOn" @onchange="e => row.MatchOn = (string?)e.Value" />
                        </td>
                        <td>
                            <input placeholder="Override Description" value="@row.OverrideDescription" @onchange="e => row.OverrideDescription = (string?)e.Value" />
                        </td>
                        <td>
                            <input type="checkbox" @onchange="e => row.AddOnlyForTransaction = (bool)e.Value">
                        </td>
                        <td>
                            <button class="btn" @onclick="() => PerformMatch(row)"><i class="fa fa-plus"></i></button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    /* Matched Rows */
    if (TransactionResultViewModel.MatchedRows.Any())
    {
        <hr />
        <label style="color:green; font-size:large"><strong>Matched</strong></label>

        <table style="width:auto" cellpadding="5">
            <thead>
                <tr class="border-bottom-thick">
                    <th class="border-right">Category: Section</th>
                    <th>Date</th>
                    <th>Transaction</th>
                    <th>Export As</th>
                    <th class="border-right">Amount (£)</th>
                    <th>Match Pattern</th>
                    <th>Clear</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var row in TransactionResultViewModel.MatchedRows)
                {
                    var rowClassBottom = row.IsLastRowForCategory ? "border-bottom-thick" : "border-bottom";
                    <tr class=@rowClassBottom>
                        <td class="fitwidth border-right">@row.CategorySectionDisplay</td>
                        <td class="fitwidth">@row.Transaction.Date.ToString("dd/MM")</td>
                        <td class="fitwidth">@row.Transaction.Description</td>
                        <td class="fitwidth">@row.MatchDescription</td>
                        <td class="border-right" style=@row.StyleColor>@row.DisplayAmount</td>
                        <td class="fitwidth" style="color:darkslategray">@row.MatchPattern</td>
                        <td>
                            <button class="btn" @onclick="() => ClearMatch(row)"><i class="fa fa-trash"></i></button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

@code
{
    /// <summary> Display message after "Reverse File" called </summary>
    private string? LastActionResult;
    private const string _success = "Success!";

    private DateOnly? Month;

    private ImmutableArray<CategoryHeader>? Categories;
    private ImmutableArray<SectionSelectorRow>? AllSections;

    private string? NewSectionCategoryName;
    private string? NewSectionName;

    private ImmutableArray<Transaction>? LoadedTransactions;

    private CategorisationResult? LatestCategorisationResult;
    private TransactionResultViewModel? TransactionResultViewModel;

    protected override Task OnInitializedAsync()
    {
        Month = _InitialiseMonth();
        _RefreshCategories();

        return Task.CompletedTask;
    }

    private bool TransactionsFullyLoaded() =>
        Categories.HasValue && AllSections.HasValue && TransactionResultViewModel != null;

    private static DateOnly _InitialiseMonth()
    {
        var now = DateTime.Now;
        return new DateOnly(now.Year, now.Month, 1).AddMonths(-1);        
    }

    private void _RefreshCategories()
    {
        if (Month.HasValue == false)
        {
            return;
        }
        var allData = Categoriser.GetSelectorData(Month!.Value);
        Categories = allData.Categories;
        AllSections = allData.Sections
            .ToImmutableArray(s => new SectionSelectorRow(s, _ToDisplay(s), Guid.NewGuid().ToString())); //Arbitrary Id

        static string _ToDisplay(SectionHeader s) => $"{s.Parent.Name}: {s.Name}";
    }

    private void OnSetMonth(string? yearAndMonth)
    {
        if (DateOnly.TryParseExact(yearAndMonth, "yyyy-MM", out var parsed))
        {
            _SetMonth(parsed);
        }
    }

    private void SkipMonth(int months) =>
        _SetMonth(Month?.AddMonths(months) ?? _InitialiseMonth());

    private void _SetMonth(DateOnly month)
    {
        Month = month;
        _RefreshCategoriesAndMatchedTransactions();        
    }

    private void _RefreshCategoriesAndMatchedTransactions()
    {
        _RefreshCategories();
        _RefreshMatchedTransactions();
    }

    private void CreateNewSection()
    {
        var category = Categories?.SingleOrDefault(x => x.Name == NewSectionCategoryName);
        if (category == null || NewSectionName.IsNullOrWhiteSpace())
        {
            return;
        }
        Categoriser.AddSection(category, NewSectionName!, matchMonthOnly: Month);

        _RefreshCategoriesAndMatchedTransactions();

        NewSectionCategoryName = null;
        NewSectionName = null;
    }

    private async Task PerformMatch(TransactionRowUnMatched row)
    {
        LastActionResult = null;

        var found = AllSections?.SingleOrDefault(x => x.Id == row.SelectionId);
        var header = found?.Header;
        if (header == null)
        {
            LastActionResult = "Could not find Section";
            return;
        }

        Result result;
        if (row.AddOnlyForTransaction)
        {
            result = Categoriser.MatchOnce(row.Transaction, header!, row.MatchOn, row.OverrideDescription);
        }
        else
        {
            if (row.MatchOn.IsNullOrEmpty())
            {
                LastActionResult = "Match On must be defined";
                return;
            }
            result = Categoriser.ApplyMatch(row.Transaction, header!, row.MatchOn!, row.OverrideDescription);
        }
        if (result.IsSuccess)
        {
            //Triggers total table refresh - task yield required to enable re-render
            LatestCategorisationResult = null;
            TransactionResultViewModel = null;

            StateHasChanged();
            await Task.Yield();

            _RefreshMatchedTransactions();

            LastActionResult = _success;
        }
        else
        {
            LastActionResult = result.Error;
        }
    }

    private void ClearMatch(TransactionRowMatched row)
    {
        LastActionResult = null;

        if (row.Section == null || row.LatestMatch == null)
        {
            LastActionResult = "Empty section or empty matches";
            return;
        }

        var result = Categoriser.DeleteMatch(row.Section!, row.LatestMatch!);
        LastActionResult = result.IsSuccess ? _success : result.Error;

        _RefreshMatchedTransactions();
    }

    private Task CoopBankReverseFile(InputFileChangeEventArgs e) =>
        _ProcessBankFileExtraction(e,
            fnProcess: s => ExcelFileHandler.CoopBank_ExtractCsvTransactionsToExcel(s),
            filePrefix: "CoopBank_Extract");

    private Task SantanderProcessFile(InputFileChangeEventArgs e) =>
        _ProcessBankFileExtraction(e,
            fnProcess: s => ExcelFileHandler.Santander_ExtractExcelTransactionsToExcel(s),
            filePrefix: "Santander_Extract");

    private async Task _ProcessBankFileExtraction(
    InputFileChangeEventArgs e,
        Func<Stream, Task<WrappedResult<byte[]>>> fnProcess,
        string filePrefix)
    {
        LastActionResult = "Running...";

        using var inputStream = await _CopyToMemoryStreamAsync(e);
        var result = await fnProcess(inputStream);

        if (result.IsSuccess)
        {
            LastActionResult = _success;

            await _DownloadBytes(
                fileName: $"{filePrefix}_{e.File.Name}_{DateTime.Now.ToFileTime()}.xlsx",
                bytes: result.Result!);
        }
        else
        {
            LastActionResult = $"Failed: {result.Error}";
        }
    }

    private async Task ExportCategorisedTransactions()
    {
        if (LatestCategorisationResult == null)
        {
            return;
        }

        var result = await ExcelFileHandler.ExportCategorisedTransactionsToExcel(LatestCategorisationResult!);
        if (!result.IsSuccess)
        {
            LastActionResult = result.Error;
            return;
        }

        LastActionResult = _success;
        await _DownloadBytes(
            fileName: $"{Month:yyyy-MM}_CategorisedTransactions_{DateTime.Now.ToFileTime()}.xlsx",
            bytes: result.Result!);
    }

    private async Task _DownloadBytes(string fileName, byte[] bytes) =>
        await JS.InvokeAsync<object>(
            "jsSaveAsFile",
            fileName,
            Convert.ToBase64String(bytes));

    private async Task Categorise(InputFileChangeEventArgs e)
    {
        LoadedTransactions = null;
        LatestCategorisationResult = null;
        TransactionResultViewModel = null;

        using var inputStream = await _CopyToMemoryStreamAsync(e);
        var transactionResult = await ExcelFileHandler.LoadTransactionsFromExcel(inputStream);
        if (transactionResult.IsSuccess)
        {
            LastActionResult = _success;

            LoadedTransactions = transactionResult.Result;
            _RefreshMatchedTransactions();
        }
        else
        {
            LastActionResult = $"Failed: {transactionResult.Error}";
        }
    }

    private void _RefreshMatchedTransactions()
    {
        if (Month.HasValue == false || LoadedTransactions.HasValue == false || AllSections.HasValue == false)
        {
            return;
        }
        var categorisationResult = Categoriser.Categorise(LoadedTransactions!.Value, month: Month!.Value);
        LatestCategorisationResult = categorisationResult;
        TransactionResultViewModel = TransactionResultViewModel.CreateFromResult(categorisationResult, AllSections!.Value);
    }

    /// <summary>
    ///  Must copy to memory stream as otherwise can raise:
    ///  "System.NotSupportedException: Synchronous reads are not supported."
    ///  when passing to service
    ///  </summary>
    private async Task<MemoryStream> _CopyToMemoryStreamAsync(InputFileChangeEventArgs e)
    {
        var inputStream = new MemoryStream();
        var stream = e.File.OpenReadStream();
        await stream.CopyToAsync(inputStream);
        inputStream.Position = 0;
        return inputStream;
    }
}